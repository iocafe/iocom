/**

  @file    ioc_memory_block.h
  @brief   Memory block object.
  @author  Pekka Lehtikoski
  @version 1.0
  @date    30.7.2018

  Communication is based on memory blocks. A memory block is byte array which is copied from
  a device to another. Under the hood his is quite a bit more complex, since only changes are
  typically passed over communication, but user of this library should not need to care about
  this. Anyhow a memory block provides one directional communication between two or more devices.
  Application accesses data by reading or writing memory blocks.

  Copyright 2018 Pekka Lehtikoski. This file is part of the iocom project and shall only be used,
  modified, and distributed under the terms of the project licensing. By continuing to use, modify,
  or distribute this file you indicate that you have read the license and understand and accept 
  it fully.

****************************************************************************************************
*/
#ifndef IOC_MEMORY_BLOCK_INCLUDED
#define IOC_MEMORY_BLOCK_INCLUDED


/** Memory block numbers reserved for specific use. Struct memory block is reserved for
    static desctiption of the IO board. This includes description inputs, outputs, etc and
    version information. Value IOC_DO_NOT_CONNECT is set at server end for remote_mblk_nr that
    it doesn't actively try to bind anything.
 */
/*@{*/
#define IOC_SAME_MBLK 0
#define IOC_STRUCT_MBLK 1
#define IOC_INPUT_MBLK 2
#define IOC_OUTPUT_MBLK 3
/*@}*/


/** Flags for ioc_initialize_memory_block() function. Bit fields.
    Note about IOC_AUTO_SEND mode: If this flag is given to source memory buffer,
    ioc_send() is called every time ioc_write() is called. Similarly IOC_AUTO_RECEIVE
    causes ioc_receive() to be called every time ioc_read() is called. This is not
    really unefficient, and can be recommended in many cases.
 */
/*@{*/
#define IOC_TARGET 1
#define IOC_SOURCE 2
#define IOC_AUTO_RECEIVE 4
#define IOC_AUTO_SEND 8
/*@}*/


/**
****************************************************************************************************
    Linked list of memory block's source buffers.
****************************************************************************************************
*/
typedef struct
{
    /** Pointer to memory block's first source buffer in linked list.
     */
    struct iocSourceBuffer *first;

    /** Pointer to memory block's last source buffer in linked list.
     */
    struct iocSourceBuffer *last;
}
iocMemoryBlocksSourceBufferList;


/**
****************************************************************************************************
    Linked list of memory block's target buffers.
****************************************************************************************************
*/
typedef struct
{
    /** Pointer to memory block's first target buffer in linked list.
     */
    struct iocTargetBuffer *first;

    /** Pointer to memory block's last target buffer in linked list.
     */
    struct iocTargetBuffer *last;
}
iocMemoryBlocksTargetBufferList;


/**
****************************************************************************************************
    This memory block in root's linked list of memory blocks.
****************************************************************************************************
*/
typedef struct
{
    /** Pointer to the root object.
     */
    iocRoot *root;

    /** Pointer to the next memory block in linked list.
     */
    struct iocMemoryBlock *next;

    /** Pointer to the previous memory block in linked list.
     */
    struct iocMemoryBlock *prev;
}
iocMemoryBlockLink;


/**
****************************************************************************************************

    Memory block callback function type.

    If multithreading is used: callbacks is called by the thread which calls ioc_receive(),
    which is worker thread is IOC_AUTO_RECEIVE is given. ioc_lock() is on when callback
    function is called.

****************************************************************************************************
*/
typedef void ioc_callback(
    struct iocMemoryBlock *mblk,
    int start_addr,
    int end_addr,
    os_ushort flags,
    void *context);

#ifndef IOC_MBLK_MAX_CALLBACK_FUNCS
#define IOC_MBLK_MAX_CALLBACK_FUNCS 2
#endif


/**
****************************************************************************************************

  @name Memory block object structure.

  This API presents IO as set of memory blocks which are copied trough communication from
  one device to another, for example IO board blocks could be "binary inputs", "analog inputs"
  and "binary outputs".

****************************************************************************************************
*/
typedef struct iocMemoryBlock
{
#if OSAL_DEBUG
    /** Debug identifier must be first item in the object structure. It is used to verify
        that a function argument is pointer to correct initialized object.
     */
    int debug_id;
#endif
    /** Flags as given to ioc_initialize_memory_block()
     */
    int flags;

    /** Pointer to data buffer.
     */
    os_uchar *buf;

    /** Memory block (data buffer) size in bytes.
     */
    int nbytes;

    /** Memory block identifier number, identifies the memory block within device.
     */
    int mblk_nr;

    /** Callback function pointers. OS_NULL if not used.
     */
    ioc_callback *func[IOC_MBLK_MAX_CALLBACK_FUNCS];

    /** Callback context for callback functions. OS_NULL if not used.
     */
    void *context[IOC_MBLK_MAX_CALLBACK_FUNCS];

    /** Linked list of memory block's source buffers.
     */
    iocMemoryBlocksSourceBufferList sbuf;

    /** Linked list of memory block's target buffers.
     */
    iocMemoryBlocksTargetBufferList tbuf;

    /** This memory block in root's linked list of memory blocks.
     */
    iocMemoryBlockLink link;

#if OSAL_DYNAMIC_MEMORY_ALLOCATION
    /** Flag indicating that the memory block structure was dynamically allocated.
     */
    os_boolean allocated;

    /** Flag indicating that the data buffer was dynamically allocated.
     */
    os_boolean buf_allocated;
#endif
}
iocMemoryBlock;


/** 
****************************************************************************************************

  @name Functions related to iocom root object

  The ioc_initialize_memory_block() function initializes or allocates new memory block object,
  and ioc_release_memory_block() releases resources associated with it. Memory allocated for the
  memory block is freed, if the memory was allocated by ioc_initialize_memory_block().

  The ioc_read() and ioc_write() functions are used to access data in memory block.

****************************************************************************************************
 */
/*@{*/

/* Initialize memory block object.
 */
iocMemoryBlock *ioc_initialize_memory_block(
    iocMemoryBlock *mblk,
    iocRoot *root,
    int mblk_nr,
    os_uchar *buf,
    int nbytes,
    int flags);

/* Release memory block object.
 */
void ioc_release_memory_block(
    iocMemoryBlock *mblk);

/* Modify memory block flag (IOC_AUTO_RECEIVE or IOC_AUTO_SEND)
 */
os_boolean ioc_set_flag(
    iocMemoryBlock *mblk,
    int flag,
    os_boolean set);

/* Write data to memory block.
 */
void ioc_write(
    iocMemoryBlock *mblk,
    int addr,
    os_uchar *buf,
    int n);

/* Read data from memory block.
 */
void ioc_read(
    iocMemoryBlock *mblk,
    int addr,
    os_uchar *buf,
    int n);

inline os_int ioc_get16(
    iocMemoryBlock* mblk,
    int addr)
{
    os_uchar buf[2];
    ioc_read(mblk, addr, buf, sizeof(buf));
    return (os_ushort)buf[0] | ((os_ushort)buf[1])<<8);
        int addr,

}

/* Send data synchronously.
 */
void ioc_send(
    iocMemoryBlock *mblk);

/* Receive data synchronously.
 */
void ioc_receive(
    iocMemoryBlock *mblk);

/* Add callback function.
 */
void ioc_add_callback(
    iocMemoryBlock *mblk,
    ioc_callback func,
    void *context);

/* Remove callback function.
 */
/* void ioc_remove_callback(
    iocMemoryBlock *mblk,
    ioc_callback func,
    void *context); */

/*@}*/

#endif
